const { PrismaClient } = require("@prisma/client");
const cloudinary = require("../../config/cloudinaryConfig");
const prisma = new PrismaClient();
const { envoyerEmail } = require("../../config/emailConfig");
const jwt = require("jsonwebtoken");
const { envoyerFichiersParMail } = require("../../utils/notifications");
/**
 * ‚úÖ Fonction pour uploader un fichier sur Cloudinary
 */
const uploadToCloudinary = (fileBuffer) => {
  return new Promise((resolve, reject) => {
    const stream = cloudinary.uploader.upload_stream(
      { folder: "proformas" },
      (error, result) => {
        if (error) reject(error);
        else resolve(result.secure_url);
      }
    );
    stream.end(fileBuffer);
  });
};

const determinerValidateurInitial = async (agent) => {
  let statutInitial = "validation_section";
  let validateurInitial = null;

  if (agent.fonction.includes("Agent")) {
    validateurInitial = await prisma.agents.findFirst({
      where: {
        section_id: agent.section_id,
        fonction: "Responsable de section",
      },
    });
  } else if (agent.fonction.includes("Responsable de section")) {
    statutInitial = "validation_entite";
    validateurInitial = await prisma.agents.findFirst({
      where: { entite_id: agent.entite_id, fonction: "Responsable d'entit√©" },
    });
  } else if (agent.fonction.includes("Responsable d'entit√©")) {
    statutInitial = "validation_entite_generale";
    validateurInitial = await prisma.agents.findFirst({
      where: { fonction: "Responsable Entit√© G√©n√©rale" },
    });
  } else if (agent.fonction.includes("Responsable Entit√© G√©n√©rale")) {
    // üö® Le REG fait une demande => Validation_entite_finance pour paiement direct
    statutInitial = "validation_entite_finance";
    validateurInitial = await prisma.agents.findFirst({
      where: { fonction: "Responsable Entit√© Financi√®re" },
    });
  } else if (agent.fonction.includes("Responsable Entit√© Financi√®re")) {
    // üö® Le REF fait une demande => Validation par le REG
    statutInitial = "validation_entite_generale";
    validateurInitial = await prisma.agents.findFirst({
      where: { fonction: "Responsable Entit√© G√©n√©rale" },
    });
  }

  return { statutInitial, validateurInitial };
};




const creerDemandePaiement = async (req, res) => {
  let { agent_id, montant, motif, requiert_proforma, beneficiaire } = req.body;

  try {
    // 1Ô∏è‚É£ R√©cup√©ration de l'agent
    const agent = await prisma.agents.findUnique({
      where: { id: parseInt(agent_id) },
    });
    if (!agent) return res.status(404).json({ message: "Agent non trouv√©." });

    // 2Ô∏è‚É£ D√©terminer le statut initial et le validateur
    const { statutInitial, validateurInitial } = await determinerValidateurInitial(agent);
    if (!validateurInitial) {
      return res.status(400).json({ message: "Aucun validateur initial trouv√© pour cette demande." });
    }

    // 3Ô∏è‚É£ Uploader la proforma avant la transaction
    let proformaUrl = null;
    if (requiert_proforma === "true" && req.file) {
      proformaUrl = await uploadToCloudinary(req.file.buffer);
    }

    // 4Ô∏è‚É£ Cr√©er la demande + proforma dans la base (transaction)
    const demandeCree = await prisma.$transaction(async (tx) => {
      const demande = await tx.demandes_paiement.create({
        data: {
          agent_id: parseInt(agent_id),
          montant: parseFloat(montant),
          motif,
          beneficiaire,
          statut: statutInitial,
          requiert_proforma: Boolean(requiert_proforma),
        },
      });

      if (proformaUrl) {
        await tx.proformas.create({
          data: {
            demande_id: demande.id,
            fichier: proformaUrl,
          },
        });
      }

      return demande;
    });

    // 5Ô∏è‚É£ R√©cup√©ration du validateur utilisateur (apr√®s transaction)
    const validateur = await prisma.utilisateurs.findFirst({
      where: { agent_id: validateurInitial.id },
      include: { agents: true },
    });

    // 6Ô∏è‚É£ Envoi d'email apr√®s la transaction
    if (validateur) {
      const validationURL = `https://achats.greenpayci.com/validations/${demandeCree.id}`;
      const sujet = `Nouvelle demande de paiement #${demandeCree.id} en attente`;
      const message = `
        <p>Bonjour ${validateur.agents.nom},</p>
        <p>Une nouvelle demande de paiement a √©t√© cr√©√©e par <strong>${agent.nom}</strong>.</p>
        <p><strong>Montant :</strong> ${montant} FCFA</p>
        <p><strong>Motif :</strong> ${motif}</p>
        <p>Merci de la valider en cliquant sur le bouton ci-dessous :</p>
        <p style="text-align: center;">
          <a href="${validationURL}" 
            style="background-color: #28a745; color: white; padding: 10px 20px; text-decoration: none; font-weight: bold; border-radius: 5px;">
            ‚úÖ Valider la demande
          </a>
        </p>
      `;

      await envoyerEmail(validateur.email, sujet, message);
    }

    // 7Ô∏è‚É£ Retour au frontend
    res.status(201).json({
      message: "Demande cr√©√©e avec succ√®s.",
      demande: demandeCree,
    });

  } catch (error) {
    console.error("‚ùå Erreur :", error);
    res.status(500).json({ message: "Erreur serveur.", error });
  }
};


const modifierDemandePaiement = async (req, res) => {
  const { demande_id } = req.params;
  const { montant, motif, requiert_proforma, beneficiaire, statut, moyen_paiement } = req.body;

  const documents = Array.isArray(req.body.documents) ? req.body.documents : [req.body.documents];
  const types = Array.isArray(req.body.types) ? req.body.types : [req.body.types];

  try {
    const demande = await prisma.demandes_paiement.findUnique({
      where: { id: parseInt(demande_id) },
      include: { proformas: true },
    });

    if (!demande) return res.status(404).json({ message: "Demande non trouv√©e." });

    const transitionsAutorisees = {
      validation_entite_generale: ["en_attente_paiement", "paye", "rejete"],
      en_attente_paiement: ["paye", "rejete"],
    };

    const transitionsPossibles = transitionsAutorisees[demande.statut] || [];
    if (!transitionsPossibles.includes(statut)) {
      return res.status(400).json({ message: `Changement de statut non autoris√© depuis '${demande.statut}' vers '${statut}'.` });
    }

    const result = await prisma.$transaction(async (tx) => {
      // üíæ en_attente_paiement ‚Üí stocker le lien sign√© REG
      if (statut === "en_attente_paiement") {
        const indexReg = types.findIndex(t => t === "signe_reg");
        if (indexReg !== -1 && documents[indexReg]) {
          await tx.demandes_paiement.update({
            where: { id: parseInt(demande_id) },
            data: {
              demande_physique_signee_url: documents[indexReg],
            },
          });
        }
      }

      // üíæ paye ‚Üí cr√©er ligne paiement + documents li√©s
      if (statut === "paye") {
        const paiement = await tx.paiements.create({
          data: {
            demande_id: parseInt(demande_id),
            moyen_paiement,
          },
        });

        const docsPaiement = documents
          .map((url, idx) => ({ url, type: types[idx] }))
          .filter(doc => doc.type === "preuve_paiement");

        for (const doc of docsPaiement) {
          await tx.documents_paiements.create({
            data: {
              paiement_id: paiement.id,
              url: doc.url,
              type: doc.type,
            },
          });
        }
      }

      // ‚öôÔ∏è Mise √† jour g√©n√©rale
      const updated = await tx.demandes_paiement.update({
        where: { id: parseInt(demande_id) },
        data: {
          montant: montant ? parseFloat(montant) : demande.montant,
          motif: motif || demande.motif,
          beneficiaire: beneficiaire || demande.beneficiaire,
          requiert_proforma: requiert_proforma === "true",
          statut,
        },
      });

      return updated;
    });

    // ‚úâÔ∏è Envoi des fichiers par mail (√† garder)
    await envoyerFichiersParMail(parseInt(demande_id));

    return res.status(200).json({
      message: "Demande mise √† jour avec succ√®s.",
      demande: result
    });
  } catch (error) {
    console.error("üî• Erreur :", error);
    return res.status(500).json({ message: "Erreur serveur", error });
  }
};





/**
 * ‚úÖ Supprimer une demande (soft delete)
 */
const supprimerDemandePaiement = async (req, res) => {
  const { demande_id } = req.params;

  try {
    const demande = await prisma.demandes_paiement.findUnique({
      where: { id: parseInt(demande_id) },
      include : {
        validations : true
      }
    });

    if (!demande)
      return res.status(404).json({ message: "Demande non trouv√©e." });

    if(demande.validations.length > 0) {
      return res.status(400).json({ message: "Demande d√©j√† valid√©e." });
    }

    const validations = await prisma.validations.findMany({
      where: { demande_id: parseInt(demande_id) },
    });
    if (validations.length > 0) {
      return res
        .status(400)
        .json({ message: "Suppression impossible apr√®s validation." });
    }

    await prisma.demandes_paiement.update({
      where: { id: parseInt(demande_id) },
      data: { deleted_at: new Date() },
    });

    res
      .status(200)
      .json({ message: "Demande supprim√©e avec succ√®s (soft delete)." });
  } catch (error) {
    console.error("Erreur :", error);
    res.status(500).json({ message: "Erreur serveur.", error });
  }
};

const getDemandesPaiement = async (req, res) => {
  const { page = 1, limit = 10, utilisateur_id } = req.query;
  const offset = (page - 1) * limit;

  try {
    const utilisateur = await prisma.utilisateurs.findUnique({
      where: { id: Number(utilisateur_id) },
      include: { agents: true },
    });

    if (!utilisateur)
      return res.status(404).json({ message: "Utilisateur non trouv√©." });

    const demandes = await prisma.demandes_paiement.findMany({
      skip: Number(offset),
      take: Number(limit),
      orderBy: { date_creation: "desc" },
      where: {
        agent_id: parseInt(utilisateur.agent_id),
        deleted_at: null,
      },
      include: { agents: true, proformas: true, validations: true },
    });

    const totalDemandes = await prisma.demandes_paiement.count();
    const totalPages = Math.ceil(totalDemandes / limit);

    res.json({ demandes, totalPages });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
};
/**
 * ‚úÖ R√©cup√©rer une demande sp√©cifique par ID
 */
const getDemandePaiementById = async (req, res) => {
  const { demande_id } = req.params;
  try {
    const demande = await prisma.demandes_paiement.findUnique({
      where: { id: parseInt(demande_id) },
      include: {
        agents: true,
        proformas: true,
        validations: {
          include: { utilisateurs: { include: { agents: true } } },
        },
      },
    });

    if (!demande)
      return res.status(404).json({ message: "Demande non trouv√©e." });

    res.status(200).json({ demande });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur.", error });
  }
};

/**
 * ‚úÖ Stats par agent
 */
const demandesCountByUser = async (req, res) => {
  try {
    const word = req.headers.authorization;
    if (!word) {
      return res.status(401).json({ error: "Token manquant" });
    }

    const token = word.split(" ")[1];
    const utilisateurs = jwt.decode(token);

    if (!utilisateurs || !utilisateurs.userId) {
      return res.status(401).json({ error: "Token invalide" });
    }

    // üìå R√©cup√©rer l'utilisateur et son agent associ√©
    const user = await prisma.utilisateurs.findUnique({
      where: { id: utilisateurs.userId },
      include: { agents: true },
    });

    if (!user || !user.agents) {
      return res.status(404).json({ error: "Agent non trouv√©" });
    }
    
    const agentId = parseInt(user.agents.id);

    // üìå R√©cup√©ration des statistiques en une seule requ√™te group√©e
    const [
      nbDemandes,
      montantTotalDemandes,
      nbDemandesPending,
      montantTotalDemandesPending,
      nbDemandesApprouvees,
      nbDemandesRejetees,
      nbPaiementsRecus,
      montantTotalPaiementsRecus
    ] = await Promise.all([
      prisma.demandes_paiement.count({ where: { agent_id: agentId } }),
      prisma.demandes_paiement.aggregate({
        _sum: { montant: true },
        where: { agent_id: agentId },
      }),
      prisma.demandes_paiement.count({
        where: {
          agent_id: agentId,
          validations: { none: {} }, // Aucune validation associ√©e
        },
      }),
      prisma.demandes_paiement.aggregate({
        _sum: { montant: true },
        where: {
          agent_id: agentId,
          validations: { none: {} },
        },
      }),
      prisma.demandes_paiement.count({
        where: {
          statut: { notIn: ["rejete", "validation_section"] },
          agent_id: agentId,
        },
      }),
      prisma.demandes_paiement.count({
        where: { statut: "rejete", agent_id: agentId },
      }),
      prisma.demandes_paiement.count({
        where: { statut: "paye", agent_id: agentId },
      }),
      prisma.demandes_paiement.aggregate({
        _sum: { montant: true },
        where: {
          statut: "paye",
          agent_id: agentId,
        },
      }),
    ]);

    // üìå Construction de la r√©ponse
    const statsAgent = {
      nbDemandes,
      montantTotalDemandes: montantTotalDemandes._sum.montant || 0,
      nbDemandesPending,
      montantTotalDemandesPending: montantTotalDemandesPending._sum.montant || 0,
      nbDemandesApprouvees,
      nbDemandesRejetees,
      nbPaiementsRecus,
      montantTotalPaiementsRecus: montantTotalPaiementsRecus._sum.montant || 0,
    };

    console.log(statsAgent);
    return res.json(statsAgent);
  } catch (error) {
    console.error(error);
    return res.status(500).json({ error: "Erreur serveur" });
  }
};
/**
 * ‚úÖ Stats par section
 */
const demandesCountByResponsableSection = async (req, res) => {
  try {
    const word = req.headers.authorization;
    if (!word) {
      return res.status(401).json({ error: "Token manquant" });
    }

    const token = word.split(" ")[1]; // D√©coupe correctement le token
    const utilisateurs = jwt.decode(token);

    if (!utilisateurs || !utilisateurs.userId) {
      return res.status(401).json({ error: "Token invalide" });
    }

    // R√©cup√©rer l'utilisateur et son agent associ√©
    const user = await prisma.utilisateurs.findUnique({
      where: { id: utilisateurs.userId },
      include: { agents: true },
    });

    if (!user || !user.agents) {
      return res.status(404).json({ error: "Agent non trouv√©" });
    }

    const agentId = parseInt(user.agents.id);
    const sectionId = parseInt(user.agents.section_id);

    // üìå Filtrage du mois en cours
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    const lastDayOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);

    // üìå R√©cup√©ration des statistiques en une seule requ√™te group√©e
    const [
      nbDemandes,
      montantTotalDemandes,
      nbDemandesPending,
      nbDemandesApprouvees,
      nbDemandesRejetees,
      nbDemandesENAttentePaiement,
      nbDemandesENAttenteValidation,
      montantDemandesENAttenteValidation,
      nbDemandesApprouveesCeMois,
      nbDemandesRejeteesCeMois,
      nbDemandeValid√©esEtAuPaiement,
      montantDemandeValid√©es,
      montantTotalPaiementsRecus
    ] = await Promise.all([
      prisma.demandes_paiement.count({ where: { agent_id: agentId } }),
      prisma.demandes_paiement.aggregate({
        _sum: { montant: true },
        where: { agent_id: agentId },
      }),
      prisma.demandes_paiement.count({ where: { agent_id: agentId, validations: { none: {} } } }),
      prisma.demandes_paiement.count({ where: { statut: { notIn: ["rejete", "validation_entite"] }, agent_id: agentId } }),
      prisma.demandes_paiement.count({ where: { statut: "rejete", agent_id: agentId } }),
      prisma.demandes_paiement.count({ where: { statut: "validation_entite_finance", agent_id: agentId } }),
      prisma.demandes_paiement.count({ where: { statut: "validation_section", agents: { section_id: sectionId, superieur_id: agentId } } }),
      prisma.demandes_paiement.aggregate({ _sum: { montant: true }, where: { statut: "validation_section", agents: { section_id: sectionId, superieur_id: agentId } } }),
      prisma.validations.count({ where: { statut: "approuve", date_validation: { gte: firstDayOfMonth, lte: lastDayOfMonth }, demandes_paiement: { agents: { section_id: sectionId, superieur_id: agentId } } } }),
      prisma.validations.count({ where: { statut: "rejete", date_validation: { gte: firstDayOfMonth, lte: lastDayOfMonth }, demandes_paiement: { agents: { section_id: sectionId, superieur_id: agentId } } } }),
      prisma.demandes_paiement.count({ where: { statut: "validation_entite_finance", agents: { section_id: sectionId, superieur_id: agentId } } }),
      prisma.demandes_paiement.aggregate({ _sum: { montant: true }, where: { statut: "paye", agents: { section_id: sectionId, superieur_id: agentId } } }),
      prisma.demandes_paiement.aggregate({ _sum: { montant: true }, where: { paiements: { some: {} }, agent_id: agentId } }),
    ]);

    // üìå Construction de la r√©ponse
    const statsResponsable = {
      nbDemandes,
      montantTotalDemandes: montantTotalDemandes._sum.montant || 0,
      nbDemandesPending,
      nbDemandesApprouvees,
      nbDemandesRejetees,
      nbDemandesENAttentePaiement,
      nbDemandesENAttenteValidation,
      montantDemandesENAttenteValidation: montantDemandesENAttenteValidation._sum.montant || 0,
      nbDemandesApprouveesCeMois,
      nbDemandesRejeteesCeMois,
      nbDemandeValid√©esEtAuPaiement,
      montantDemandeValid√©es: montantDemandeValid√©es._sum.montant || 0,
      montantTotalPaiementsRecus: montantTotalPaiementsRecus._sum.montant || 0,
    };

    console.log(statsResponsable);
    return res.json(statsResponsable);
  } catch (error) {
    console.error(error);
    return res.status(500).json({ error: "Erreur serveur" });
  }
};



const demandesCountByRef = async (req, res) => {

  try {
      const word = req.headers.authorization;
      if (!word) {
          return res.status(401).json({ error: "Token manquant" });
      }
  
      const token = word.split(" ")[1]; // D√©coupe correctement le token
      const utilisateurs = jwt.decode(token);
  
      if (!utilisateurs || !utilisateurs.userId) {
          return res.status(401).json({ error: "Token invalide" });
      }
  
      // R√©cup√©rer l'utilisateur et son agent associ√©
      const user = await prisma.utilisateurs.findUnique({
          where: { id: utilisateurs.userId },
          include: { agents: true },
      });
      
      if (!user || !user.agents) {
          return res.status(404).json({ error: "Agent non trouv√©" });
      }
      
      const agentId = parseInt(user.agents.id);
  
      // üìå Regroupement des requ√™tes pour optimiser les performances
      const [
          nbPaiements,
          montantPaiements,
          nbPaiementAttente,
          nbPaiementRejetees,
          nbPaiementRef,
          montantPaiementRef,
          montantPaiementEnAttenteValidation,
          nbPaiementTypePaiement
      ] = await Promise.all([
          prisma.paiements.count(),
          prisma.demandes_paiement.aggregate({
              _sum: { montant: true },
              where: { paiements: { some: {} } }
          }),
          prisma.demandes_paiement.count({
              where: { statut: "validation_entite_finance" }
          }),
          prisma.demandes_paiement.count({
              where: { statut: "rejete" }
          }),
          prisma.demandes_paiement.count({
              where: { agent_id: agentId }
          }),
          prisma.demandes_paiement.aggregate({
              _sum: { montant: true },
              where: { agent_id: agentId }
          }),
          prisma.demandes_paiement.count({
              where: {
                  validations: { none: {} },
                  agent_id: agentId
              }
          }),
          prisma.paiements.groupBy({
              by: ["moyen_paiement"],
              _count: { moyen_paiement: true }
          })
      ]);
  
      // üìå Transformer la r√©ponse pour la r√©partition des types de paiement
      const result = nbPaiementTypePaiement.reduce((acc, paiement) => {
          acc[paiement.moyen_paiement] = paiement._count.moyen_paiement;
          return acc;
      }, {});
  
      // üìå Construction de la r√©ponse
      const statsDaf = {
          nbPaiements,
          montantPaiements: montantPaiements._sum.montant || 0,
          nbPaiementAttente,
          nbPaiementRejetees,
          nbPaiementRef,
          montantPaiementRef: montantPaiementRef._sum.montant || 0,
          montantPaiementEnAttenteValidation,
          result
      };
  
      console.log(statsDaf);
      return res.json(statsDaf);
  } catch (error) {
      console.log(error);
      return res.status(500).json({ error: "Erreur serveur." });
  }
};

const demandesCountByReg = async (req, res) => {
  try {
    const word = req.headers.authorization;
    if (!word) {
      return res.status(401).json({ error: "Token manquant" });
    }

    const token = word.split(" ")[1];
    const utilisateurs = jwt.decode(token);

    if (!utilisateurs || !utilisateurs.userId) {
      return res.status(401).json({ error: "Token invalide" });
    }

    // üìå R√©cup√©rer toutes les donn√©es n√©cessaires en parall√®le
    const [
      nbPaiements,
      montantPaiements,
      nbDemandesEnAttenteValidation,
      nbDemandesApprouvees,
      nbDemandesRejetees,
      nbDemandePaiementAttente,
      montantTotalPaiements,
      nbPaiementsType
    ] = await Promise.all([
      prisma.paiements.count(),
      prisma.demandes_paiement.aggregate({
        _sum: { montant: true },
        where: { statut: "paye" }
      }),
      prisma.demandes_paiement.count({
        where: { validations: { none: {} } }
      }),
      prisma.demandes_paiement.count({
        where: { validations: { some: { statut: "approuve" } } }
      }),
      prisma.demandes_paiement.count({
        where: { validations: { some: { statut: "rejete" } } }
      }),
      prisma.demandes_paiement.count({
        where: { statut: "validation_entite_finance" }
      }),
      prisma.demandes_paiement.aggregate({
        _sum: { montant: true },
        where: { statut: "paye" }
      }),
      prisma.paiements.groupBy({
        by: ["moyen_paiement"],
        _count: { moyen_paiement: true }
      })
    ]);

    // üìå Transformer la r√©ponse pour la r√©partition des types de paiement
    const result = nbPaiementsType.reduce((acc, paiement) => {
      acc[paiement.moyen_paiement] = paiement._count.moyen_paiement;
      return acc;
    }, {});

    // üìå Construire la r√©ponse API
    const statsDG = {
      nbPaiements,
      montantPaiements: montantPaiements._sum.montant || 0,
      nbDemandesEnAttenteValidation,
      nbDemandesApprouvees,
      nbDemandesRejetees,
      nbDemandePaiementAttente,
      montantTotalPaiements: montantTotalPaiements._sum.montant || 0,
      result
    };

    console.log(statsDG);
    return res.json(statsDG);
  } catch (error) {
    console.error(error);
    return res.status(500).json({ error: "Erreur serveur." });
  }
};


const demandesCountByResponsableEntite = async (req, res) => {
  try {
      const word = req.headers.authorization;
      if (!word) {
          return res.status(401).json({ error: "Token manquant" });
      }

      const token = word.split(" ")[1];
      const utilisateurs = jwt.decode(token);

      if (!utilisateurs || !utilisateurs.userId) {
          return res.status(401).json({ error: "Token invalide" });
      }

      // R√©cup√©rer l'utilisateur et son agent associ√©
      const user = await prisma.utilisateurs.findUnique({
          where: { id: utilisateurs.userId },
          include: { agents: true },
      });

      if (!user || !user.agents) {
          return res.status(404).json({ error: "Agent non trouv√©" });
      }

      const entiteId = parseInt(user.agents.entite_id);
      
      // üìå Regrouper toutes les requ√™tes pour am√©liorer les performances
      const [
          nbDemandes,
          montantDemandes,
          nbDemandesAttente,
          nbDemandesApprouvees,
          nbDemandesRejetees,
          nbPaiements,
          montantPaiements,
          nbPaiementsAttente,
          nbPaiementsType
      ] = await Promise.all([
          prisma.demandes_paiement.count({ where: { agents: { entite_id: entiteId } } }),
          prisma.demandes_paiement.aggregate({ _sum: { montant: true }, where: { agents: { entite_id: entiteId } } }),
          prisma.demandes_paiement.count({ where: { statut: "validation_entite", agents: { entite_id: entiteId } } }),
          prisma.validations.count({ where: { statut: "approuve", demandes_paiement: { agents: { entite_id: entiteId } } } }),
          prisma.validations.count({ where: { statut: "rejete", demandes_paiement: { agents: { entite_id: entiteId } } } }),
          prisma.paiements.count({ where: { demandes_paiement: { agents: { entite_id: entiteId } } } }),
          prisma.demandes_paiement.aggregate({ _sum: { montant: true }, where: { paiements: { some: {} }, agents: { entite_id: entiteId } } }),
          prisma.demandes_paiement.count({ where: { statut: "validation_entite_finance", agents: { entite_id: entiteId } } }),
          prisma.paiements.groupBy({
              by: ["moyen_paiement"],
              _count: { moyen_paiement: true },
              where: { demandes_paiement: { agents: { entite_id: entiteId } } }
          })
      ]);

      // üìå Transformer la r√©ponse en format JSON structur√©
      const result = nbPaiementsType.reduce((acc, paiement) => {
          acc[paiement.moyen_paiement] = paiement._count.moyen_paiement;
          return acc;
      }, {});

      // üìå Construction de la r√©ponse
      const statsResponsableEntite = {
          nbDemandes,
          montantDemandes: montantDemandes._sum.montant || 0,
          nbDemandesAttente,
          nbDemandesApprouvees,
          nbDemandesRejetees,
          nbPaiements,
          montantPaiements: montantPaiements._sum.montant || 0,
          nbPaiementsAttente,
          result
      };
      console.log(statsResponsableEntite);
      return res.json(statsResponsableEntite);
  } catch (error) {
      console.log(error);
      res.status(500).json({ error: "Erreur serveur." });
  }
};


  

module.exports = {
  creerDemandePaiement,
  modifierDemandePaiement,
  supprimerDemandePaiement,
  getDemandesPaiement,
  getDemandePaiementById,
  demandesCountByUser,
  demandesCountByResponsableSection,
  demandesCountByRef,
  demandesCountByReg,
  demandesCountByResponsableEntite
};
